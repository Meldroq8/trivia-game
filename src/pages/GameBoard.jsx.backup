import { useState, useEffect, useRef } from 'react'
import { useNavigate } from 'react-router-dom'
import sampleData from '../data/sampleQuestions.json'
import PresentationModeToggle from '../components/PresentationModeToggle'

function GameBoard({ gameState, setGameState }) {
  const navigate = useNavigate()
  const containerRef = useRef(null)
  const headerRef = useRef(null)
  const footerRef = useRef(null)
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })
  const [headerHeight, setHeaderHeight] = useState(0)
  const [footerHeight, setFooterHeight] = useState(0)

  useEffect(() => {
    if (!gameState.selectedCategories.length) {
      navigate('/categories')
      return
    }

    const updateDimensions = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect()
        setDimensions({ width: rect.width, height: rect.height })
      }

      if (headerRef.current) {
        const headerRect = headerRef.current.getBoundingClientRect()
        setHeaderHeight(headerRect.height)
      }

      if (footerRef.current) {
        const footerRect = footerRef.current.getBoundingClientRect()
        setFooterHeight(footerRect.height)
      }
    }

    updateDimensions()
    window.addEventListener('resize', updateDimensions)
    return () => window.removeEventListener('resize', updateDimensions)
  }, [gameState.selectedCategories.length, navigate])

  const getCategoryById = (categoryId) => {
    const savedData = localStorage.getItem('triviaData')
    if (savedData) {
      const data = JSON.parse(savedData)
      return data.categories.find(cat => cat.id === categoryId)
    }
    return sampleData.categories.find(cat => cat.id === categoryId)
  }

  const isQuestionUsed = (categoryId, questionIndex) => {
    return gameState.usedQuestions.has(`${categoryId}-${questionIndex}`)
  }

  const isPointValueUsed = (categoryId, points, buttonIndex) => {
    // Check if this specific button has been used for this category
    // Each button is tracked individually with category-points-buttonIndex

    // Create a key pattern for this specific button
    const pointValueKey = `${categoryId}-${points}-${buttonIndex}`

    // Check if this specific button was used
    const usedQuestions = Array.from(gameState.usedQuestions)
    const isUsed = gameState.usedPointValues && gameState.usedPointValues.has(pointValueKey)

    console.log(`ðŸ” Button state check: ${categoryId} ${points}pts button ${buttonIndex}`)
    console.log(`   Point value key: ${pointValueKey}`)
    console.log(`   Used point values:`, gameState.usedPointValues ? Array.from(gameState.usedPointValues) : 'undefined')
    console.log(`   Button disabled: ${isUsed}`)

    return isUsed || false
  }

  const getPoints = () => [200, 400, 600]

  const getQuestionPoints = (questionIndex) => {
    const points = getPoints()
    return points[questionIndex]
  }

  const handleQuestionClick = (categoryId, points, buttonIndex = 0) => {
    const category = getCategoryById(categoryId)
    if (!category) return

    // Get questions from the questions object using categoryId as key
    const savedData = localStorage.getItem('triviaData')
    let questions
    if (savedData) {
      try {
        const data = JSON.parse(savedData)
        questions = data.questions && data.questions[categoryId]
      } catch (error) {
        console.error('Error parsing localStorage data:', error)
        questions = sampleData.questions[categoryId]
      }
    } else {
      questions = sampleData.questions[categoryId]
    }

    // Fallback to sampleData if questions not found
    if (!questions) {
      questions = sampleData.questions[categoryId]
    }

    if (!questions || questions.length === 0) {
      console.warn(`No questions found for category: ${categoryId}`)
      return
    }

    // Determine difficulty based on points
    let targetDifficulty
    if (points === 200) {
      targetDifficulty = 'easy'
    } else if (points === 400) {
      targetDifficulty = 'medium'
    } else if (points === 600) {
      targetDifficulty = 'hard'
    } else {
      console.warn(`Invalid points value: ${points}`)
      return
    }

    // Filter questions by difficulty
    const questionsWithDifficulty = questions.filter(q => q.difficulty === targetDifficulty)

    console.log(`ðŸŽ¯ Looking for ${targetDifficulty} questions (${points} points) in category: ${categoryId}`)
    console.log(`ðŸ“Š Found ${questionsWithDifficulty.length} ${targetDifficulty} questions out of ${questions.length} total`)

    if (questionsWithDifficulty.length === 0) {
      console.warn(`âŒ No ${targetDifficulty} questions found for category: ${categoryId}`)
      console.log(`ðŸ“‹ Available difficulties:`, questions.map(q => q.difficulty))

      // Smart fallback: try nearby difficulties
      let fallbackDifficulty = null
      let fallbackQuestions = []

      if (targetDifficulty === 'easy') {
        // For easy (200): try medium, then hard
        console.log(`ðŸ”„ Trying fallback: easy â†’ medium â†’ hard`)
        fallbackQuestions = questions.filter(q => q.difficulty === 'medium')
        if (fallbackQuestions.length > 0) {
          fallbackDifficulty = 'medium'
        } else {
          fallbackQuestions = questions.filter(q => q.difficulty === 'hard')
          fallbackDifficulty = 'hard'
        }
      } else if (targetDifficulty === 'medium') {
        // For medium (400): try easy, then hard
        console.log(`ðŸ”„ Trying fallback: medium â†’ easy â†’ hard`)
        fallbackQuestions = questions.filter(q => q.difficulty === 'easy')
        if (fallbackQuestions.length > 0) {
          fallbackDifficulty = 'easy'
        } else {
          fallbackQuestions = questions.filter(q => q.difficulty === 'hard')
          fallbackDifficulty = 'hard'
        }
      } else if (targetDifficulty === 'hard') {
        // For hard (600): try medium, then easy
        console.log(`ðŸ”„ Trying fallback: hard â†’ medium â†’ easy`)
        fallbackQuestions = questions.filter(q => q.difficulty === 'medium')
        if (fallbackQuestions.length > 0) {
          fallbackDifficulty = 'medium'
        } else {
          fallbackQuestions = questions.filter(q => q.difficulty === 'easy')
          fallbackDifficulty = 'easy'
        }
      }

      if (fallbackQuestions.length > 0) {
        // Get unused questions from fallback difficulty
        const unusedFallbackQuestions = fallbackQuestions.filter(question => {
          const originalIndex = questions.indexOf(question)
          return !isQuestionUsed(categoryId, originalIndex)
        })

        if (unusedFallbackQuestions.length > 0) {
          const fallbackQuestion = unusedFallbackQuestions[Math.floor(Math.random() * unusedFallbackQuestions.length)]
          const fallbackIndex = questions.indexOf(fallbackQuestion)

          console.log(`âœ… Using ${fallbackDifficulty} question as fallback: "${fallbackQuestion.text}" (requested ${points} points)`)

          setGameState(prev => ({
            ...prev,
            currentQuestion: {
              categoryId,
              questionIndex: fallbackIndex,
              question: fallbackQuestion,
              points,
              category: category.name,
              questionKey: `${categoryId}-${fallbackIndex}`,
              pointValueKey: `${categoryId}-${points}-${buttonIndex}`
            }
          }))

          navigate('/question')
          return
        }
      }

      // Final fallback: use any unused question
      const anyUnusedQuestions = questions.filter((question, index) => {
        return !isQuestionUsed(categoryId, index)
      })

      if (anyUnusedQuestions.length > 0) {
        const finalFallback = anyUnusedQuestions[0]
        const finalIndex = questions.indexOf(finalFallback)
        console.log(`ðŸ†˜ Final fallback: using any available question (${finalFallback.difficulty})`)

        setGameState(prev => ({
          ...prev,
          currentQuestion: {
            categoryId,
            questionIndex: finalIndex,
            question: finalFallback,
            points,
            category: category.name,
            questionKey: `${categoryId}-${finalIndex}`,
            pointValueKey: `${categoryId}-${points}-${buttonIndex}`
          }
        }))

        navigate('/question')
      } else {
        console.error(`âŒ No unused questions available in category: ${categoryId}`)
      }
      return
    }

    // Get unused questions of the target difficulty
    const availableQuestions = questionsWithDifficulty.filter((question, index) => {
      const originalIndex = questions.indexOf(question)
      return !isQuestionUsed(categoryId, originalIndex)
    })

    if (availableQuestions.length === 0) {
      console.warn(`No unused ${targetDifficulty} questions available for category: ${categoryId}`)
      return
    }

    // Pick a random question from available ones
    const randomQuestion = availableQuestions[Math.floor(Math.random() * availableQuestions.length)]
    const originalQuestionIndex = questions.indexOf(randomQuestion)

    console.log(`âœ… Selected ${targetDifficulty} question: "${randomQuestion.text}" (${points} points)`)

    setGameState(prev => ({
      ...prev,
      currentQuestion: {
        categoryId,
        questionIndex: originalQuestionIndex,
        question: randomQuestion,
        points,
        category: category.name,
        questionKey: `${categoryId}-${originalQuestionIndex}`,
        pointValueKey: `${categoryId}-${points}-${buttonIndex}`
      }
    }))

    navigate('/question')
  }

  // Auto-scaling system to fit entire screen without scrolling
  const getResponsiveStyles = () => {
    const W = dimensions.width || window.innerWidth
    const H = dimensions.height || window.innerHeight

    // Mobile-first responsive calculations
    const isMobile = W < 768

    // Calculate available space for game board with mobile adjustments
    const actualHeaderHeight = headerHeight || (isMobile ? 60 : 80)
    const actualFooterHeight = footerHeight || (isMobile ? 80 : 100)
    const padding = isMobile ? 16 : 40        // Less padding on mobile
    const availableHeight = H - actualHeaderHeight - actualFooterHeight - padding
    const availableWidth = W - padding

    // Calculate grid spacing - smaller gaps on mobile
    const gridGap = isMobile ? 16 : 24  // gap-4 vs gap-6 in Tailwind
    const columnGaps = gridGap * 2      // 2 gaps between 3 columns

    // Calculate optimal card size based on 3x2 grid layout
    const maxCardWidth = (availableWidth - columnGaps) / 3  // 3 columns with gaps

    // More aggressive scaling for mobile - fit 2 rows of cards + buttons
    const cardPlusButtonsHeight = isMobile ? availableHeight / 2.2 : availableHeight / 3
    const maxCardHeight = cardPlusButtonsHeight * 0.6  // Card takes 60% of vertical space

    // Calculate button dimensions first with mobile optimization
    const baseCardWidth = Math.min(maxCardWidth, maxCardHeight * 1.2)

    // More aggressive button scaling for mobile
    const buttonWidthRatio = isMobile ? 0.85 : 0.8
    const buttonHeightRatio = isMobile ? 0.25 : 0.2

    const buttonWidth = Math.max(isMobile ? 35 : 40, baseCardWidth * buttonWidthRatio)
    const buttonHeight = Math.max(isMobile ? 18 : 20, baseCardWidth * 0.75 * buttonHeightRatio)

    // Calculate total width of 2 buttons with gap (8px for gap-2 in Tailwind)
    const totalButtonsWidth = (buttonWidth * 2) + 8

    // Set card width to match the total width of the 2 buttons below
    const cardWidth = totalButtonsWidth
    const cardHeight = cardWidth * 0.75

    // Scale font size based on button size with mobile adjustments
    const fontSizeRatio = isMobile ? 0.12 : 0.15
    const fontSize = Math.max(6, Math.min(isMobile ? 24 : 32, buttonWidth * fontSizeRatio))

    // Scale header and footer elements with mobile optimization
    const headerFontSize = Math.max(isMobile ? 10 : 12, Math.min(isMobile ? 18 : 24, W * (isMobile ? 0.035 : 0.02)))
    const footerButtonSize = Math.max(isMobile ? 25 : 30, Math.min(isMobile ? 45 : 60, H * (isMobile ? 0.06 : 0.08)))

    return {
      cardWidth: Math.max(isMobile ? 50 : 60, cardWidth),
      cardHeight: Math.max(isMobile ? 35 : 45, cardHeight),
      buttonWidth: Math.max(isMobile ? 35 : 40, buttonWidth),
      buttonHeight: Math.max(isMobile ? 18 : 20, buttonHeight),
      fontSize: fontSize,
      headerFontSize: headerFontSize,
      footerButtonSize: footerButtonSize,
      availableHeight: availableHeight,
      isMobile: isMobile
    }
  }

  const styles = getResponsiveStyles()


  if (!gameState.selectedCategories.length) {
    return <div>Loading...</div>
  }

  return (
    <div className="h-screen bg-white flex flex-col" ref={containerRef}>
      {/* Red Header Bar */}
      <div ref={headerRef} className="bg-red-600 text-white p-3 flex-shrink-0 sticky top-0 z-10">
        <div className="flex justify-between items-center">
          <div className="flex gap-3">
            <button
              onClick={() => navigate('/categories')}
              className="px-3 py-1 bg-red-700 hover:bg-red-800 text-white rounded-lg transition-colors"
              style={{ fontSize: `${styles.headerFontSize * 0.8}px` }}
            >
              Ø§Ù„Ø®Ø±ÙˆØ¬
            </button>
            <button
              onClick={() => navigate('/categories')}
              className="px-3 py-1 bg-red-700 hover:bg-red-800 text-white rounded-lg transition-colors"
              style={{ fontSize: `${styles.headerFontSize * 0.8}px` }}
            >
              Ø§Ù„Ø±Ø¬ÙˆØ¹
            </button>
            <button
              onClick={() => navigate('/results')}
              className="px-3 py-1 bg-red-700 hover:bg-red-800 text-white rounded-lg transition-colors"
              style={{ fontSize: `${styles.headerFontSize * 0.8}px` }}
            >
              Ø§Ù†Ù‡Ø§Ø¡
            </button>
          </div>

          <div className="flex items-center gap-2">
            <h1 className="font-bold text-center" style={{ fontSize: `${styles.headerFontSize * 1.2}px` }}>
              {gameState.gameName}
            </h1>
            <PresentationModeToggle />
          </div>

          <div className="flex items-center gap-4">
            <div className="text-center">
              <div className="font-bold" style={{ fontSize: `${styles.headerFontSize * 0.9}px` }}>
                {gameState.team1.name}
              </div>
              <div className="font-bold" style={{ fontSize: `${styles.headerFontSize * 1.1}px` }}>
                {gameState.team1.score}
              </div>
            </div>
            <div className="text-center">
              <div className="font-bold" style={{ fontSize: `${styles.headerFontSize * 0.9}px` }}>
                {gameState.team2.name}
              </div>
              <div className="font-bold" style={{ fontSize: `${styles.headerFontSize * 1.1}px` }}>
                {gameState.team2.score}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Game Board - 2 Rows of 3 Categories Each */}
      <div className="flex-1 bg-white flex flex-col items-center justify-center p-2">
        {/* First Row - 3 Categories with their buttons */}
        <div className={`grid grid-cols-3 ${styles.isMobile ? 'gap-4' : 'gap-6'} ${styles.isMobile ? 'mb-4' : 'mb-6'}`}>
          {gameState.selectedCategories.slice(0, 3).map(categoryId => {
            const category = getCategoryById(categoryId)
            if (!category) return null

            return (
              <div key={categoryId} className="flex flex-col items-center">
                {/* Category Card */}
                <div
                  className="relative rounded-lg overflow-hidden border-2 border-gray-300 bg-gradient-to-br from-gray-200 to-gray-400 mb-2"
                  style={{
                    width: `${styles.cardWidth}px`,
                    height: `${styles.cardHeight}px`,
                    backgroundImage: category.imageUrl ? `url(${category.imageUrl})` : 'none',
                    backgroundSize: 'cover',
                    backgroundPosition: 'center',
                    backgroundRepeat: 'no-repeat'
                  }}
                >
                  <div className="absolute inset-0 bg-black bg-opacity-20"></div>
                  <div className="absolute bottom-2 left-2 right-2 bg-red-600 text-white px-2 py-1 rounded text-center font-bold"
                       style={{ fontSize: `${styles.fontSize * 0.7}px` }}>
                    <div className="leading-tight">{category.name}</div>
                  </div>
                  {!category.imageUrl && category.image && (
                    <div className="absolute inset-0 flex items-center justify-center"
                         style={{ fontSize: `${styles.cardHeight * 0.4}px` }}>
                      {category.image}
                    </div>
                  )}
                </div>

                {/* Point Buttons for this category */}
                <div className="flex flex-col gap-1">
                  {getPoints().map((pointValue, pointIndex) => (
                    <div key={pointValue} className="flex gap-2 justify-center">
                      {[0, 1].map(buttonIndex => {
                        const uniqueKey = `${categoryId}-${pointValue}-${buttonIndex}`
                        const isDisabled = isPointValueUsed(categoryId, pointValue, buttonIndex)
                        return (
                          <button
                            key={uniqueKey}
                            onClick={() => handleQuestionClick(categoryId, pointValue, buttonIndex)}
                            disabled={isDisabled}
                            className={`border-2 font-bold rounded-full shadow-md transition-all duration-200 ${
                              isDisabled
                                ? 'bg-gray-300 border-gray-400 text-gray-500 cursor-not-allowed opacity-50'
                                : 'bg-white border-gray-300 text-red-600 hover:shadow-lg hover:scale-105'
                            }`}
                            style={{
                              width: `${styles.buttonWidth}px`,
                              height: `${styles.buttonHeight}px`,
                              fontSize: `${styles.fontSize}px`
                            }}
                          >
                            {pointValue}
                          </button>
                        )
                      })}
                    </div>
                  ))}
                </div>
              </div>
            )
          })}
        </div>

        {/* Second Row - 3 Categories with their buttons */}
        <div className={`grid grid-cols-3 ${styles.isMobile ? 'gap-4' : 'gap-6'}`}>
          {gameState.selectedCategories.slice(3, 6).map(categoryId => {
            const category = getCategoryById(categoryId)
            if (!category) return null

            return (
              <div key={categoryId} className="flex flex-col items-center">
                {/* Category Card */}
                <div
                  className="relative rounded-lg overflow-hidden border-2 border-gray-300 bg-gradient-to-br from-gray-200 to-gray-400 mb-2"
                  style={{
                    width: `${styles.cardWidth}px`,
                    height: `${styles.cardHeight}px`,
                    backgroundImage: category.imageUrl ? `url(${category.imageUrl})` : 'none',
                    backgroundSize: 'cover',
                    backgroundPosition: 'center',
                    backgroundRepeat: 'no-repeat'
                  }}
                >
                  <div className="absolute inset-0 bg-black bg-opacity-20"></div>
                  <div className="absolute bottom-2 left-2 right-2 bg-red-600 text-white px-2 py-1 rounded text-center font-bold"
                       style={{ fontSize: `${styles.fontSize * 0.7}px` }}>
                    <div className="leading-tight">{category.name}</div>
                  </div>
                  {!category.imageUrl && category.image && (
                    <div className="absolute inset-0 flex items-center justify-center"
                         style={{ fontSize: `${styles.cardHeight * 0.4}px` }}>
                      {category.image}
                    </div>
                  )}
                </div>

                {/* Point Buttons for this category */}
                <div className="flex flex-col gap-1">
                  {getPoints().map((pointValue, pointIndex) => (
                    <div key={pointValue} className="flex gap-2 justify-center">
                      {[0, 1].map(buttonIndex => {
                        const uniqueKey = `${categoryId}-${pointValue}-${buttonIndex}`
                        const isDisabled = isPointValueUsed(categoryId, pointValue, buttonIndex)
                        return (
                          <button
                            key={uniqueKey}
                            onClick={() => handleQuestionClick(categoryId, pointValue, buttonIndex)}
                            disabled={isDisabled}
                            className={`border-2 font-bold rounded-full shadow-md transition-all duration-200 ${
                              isDisabled
                                ? 'bg-gray-300 border-gray-400 text-gray-500 cursor-not-allowed opacity-50'
                                : 'bg-white border-gray-300 text-red-600 hover:shadow-lg hover:scale-105'
                            }`}
                            style={{
                              width: `${styles.buttonWidth}px`,
                              height: `${styles.buttonHeight}px`,
                              fontSize: `${styles.fontSize}px`
                            }}
                          >
                            {pointValue}
                          </button>
                        )
                      })}
                    </div>
                  ))}
                </div>
              </div>
            )
          })}
        </div>
      </div>

      {/* Footer Score Controls */}
      <div ref={footerRef} className="bg-white border-t-2 border-gray-200 p-2 flex-shrink-0 sticky bottom-0 z-10">
        <div className="flex justify-between items-center max-w-6xl mx-auto">
          {/* Team 2 Controls (Left) */}
          <div className="flex items-center gap-2">
            <button
              className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-full font-bold transition-colors"
              style={{ fontSize: `${styles.headerFontSize * 0.9}px` }}
            >
              {gameState.team2.name}
            </button>
            <button
              onClick={() => setGameState(prev => ({
                ...prev,
                team2: { ...prev.team2, score: Math.max(0, prev.team2.score - 100) }
              }))}
              className="bg-red-500 hover:bg-red-600 text-white rounded-full font-bold transition-colors"
              style={{
                width: `${styles.footerButtonSize}px`,
                height: `${styles.footerButtonSize}px`,
                fontSize: `${styles.headerFontSize}px`
              }}
            >
              -
            </button>
            <div
              className="bg-white border-2 border-gray-300 rounded-full flex items-center justify-center font-bold"
              style={{
                width: `${styles.footerButtonSize * 1.3}px`,
                height: `${styles.footerButtonSize * 1.3}px`,
                fontSize: `${styles.headerFontSize}px`
              }}
            >
              {gameState.team2.score}
            </div>
            <button
              onClick={() => setGameState(prev => ({
                ...prev,
                team2: { ...prev.team2, score: prev.team2.score + 100 }
              }))}
              className="bg-green-500 hover:bg-green-600 text-white rounded-full font-bold transition-colors"
              style={{
                width: `${styles.footerButtonSize}px`,
                height: `${styles.footerButtonSize}px`,
                fontSize: `${styles.headerFontSize}px`
              }}
            >
              +
            </button>
          </div>

          {/* Center spacing */}
          <div className="flex-1"></div>

          {/* Team 1 Controls (Right) */}
          <div className="flex items-center gap-2">
            <button
              onClick={() => setGameState(prev => ({
                ...prev,
                team1: { ...prev.team1, score: Math.max(0, prev.team1.score - 100) }
              }))}
              className="bg-red-500 hover:bg-red-600 text-white rounded-full font-bold transition-colors"
              style={{
                width: `${styles.footerButtonSize}px`,
                height: `${styles.footerButtonSize}px`,
                fontSize: `${styles.headerFontSize}px`
              }}
            >
              -
            </button>
            <div
              className="bg-white border-2 border-gray-300 rounded-full flex items-center justify-center font-bold"
              style={{
                width: `${styles.footerButtonSize * 1.3}px`,
                height: `${styles.footerButtonSize * 1.3}px`,
                fontSize: `${styles.headerFontSize}px`
              }}
            >
              {gameState.team1.score}
            </div>
            <button
              onClick={() => setGameState(prev => ({
                ...prev,
                team1: { ...prev.team1, score: prev.team1.score + 100 }
              }))}
              className="bg-green-500 hover:bg-green-600 text-white rounded-full font-bold transition-colors"
              style={{
                width: `${styles.footerButtonSize}px`,
                height: `${styles.footerButtonSize}px`,
                fontSize: `${styles.headerFontSize}px`
              }}
            >
              +
            </button>
            <button
              className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-full font-bold transition-colors"
              style={{ fontSize: `${styles.headerFontSize * 0.9}px` }}
            >
              {gameState.team1.name}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

export default GameBoard